<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>flask_signing API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>flask_signing</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">__name__ = &#34;flask_signing&#34;
__author__ = &#34;Sig Janoska-Bedi&#34;
__credits__ = [&#34;Sig Janoska-Bedi&#34;,]
__version__ = &#34;0.2.1&#34;
__license__ = &#34;BSD-3-Clause&#34;
__maintainer__ = &#34;Sig Janoska-Bedi&#34;
__email__ = &#34;signe@atreeus.com&#34;

import datetime, secrets
from flask_sqlalchemy import SQLAlchemy
from typing import Union, List, Dict, Any

class Signatures:
    &#34;&#34;&#34;
    The Signatures class handles operations related to the creation, management, and validation 
    of signing keys in the database.
    &#34;&#34;&#34;
    
    def __init__(self, app, byte_len:int=24):
        &#34;&#34;&#34;
        Initializes a new instance of the Signatures class.

        Args:
            app (Flask): A flask object to contain the context for database interactions. 
            byte_len (int, optional): The length of the generated signing keys. Defaults to 24.
        &#34;&#34;&#34;

        self.db = SQLAlchemy(app)
        self.Signing = self.get_model()
        self.db.create_all()  # this will create all necessary tables

        # self.db = database
        self.byte_len = byte_len

    def generate_key(self, length:int=None) -&gt; str:
        &#34;&#34;&#34;
        Generates a signing key with the specified byte length. 
        Note: byte length generally translates to about 1.3 times as many chars,
        see https://docs.python.org/3/library/secrets.html.

        Args:
            length (int, optional): The length of the generated signing key. Defaults to None, in which case the byte_len is used.

        Returns:
            str: The generated signing key.
        &#34;&#34;&#34;

        if not length: 
            length = self.byte_len
        return secrets.token_urlsafe(length)

    def write_key_to_database(self, scope:str=None, expiration:int=1, active:bool=True, email:str=None) -&gt; str:
        &#34;&#34;&#34;
        Writes a newly generated signing key to the database.

        This function will continuously attempt to generate a key until a unique one is created. 

        Args:
            scope (str): The scope within which the signing key will be valid. Defaults to None.
            expiration (int, optional): The number of hours after which the signing key will expire. 
                If not provided or equals 0, the expiration will be set to zero. Defaults to 1.
            active (bool, optional): The status of the signing key. Defaults to True.
            email (str, optional): The email associated with the signing key. Defaults to None.

        Returns:
            str: The generated and written signing key.
        &#34;&#34;&#34;
        Signing = self.get_model()

        # loop until a unique key is generated
        while True:
            key = self.generate_key()
            if not Signing.query.filter_by(signature=key).first(): break

        new_key = Signing(
                        signature=key, 
                        scope=scope.lower() if scope else &#34;&#34;,
                        email=email.lower() if email else &#34;&#34;, 
                        active=active,
                        expiration=(datetime.datetime.utcnow() + datetime.timedelta(hours=expiration)) if expiration else 0,
                        timestamp=datetime.datetime.utcnow(),
        )

        self.db.session.add(new_key)
        self.db.session.commit()

        return key

    def expire_key(self, key):

        &#34;&#34;&#34;
        Expires a signing key in the database.

        This function finds the key in the database and disables it by setting its &#39;active&#39; status to False.
        If the key does not exist, the function returns False and an HTTP status code 500.

        Args:
            key (str): The signing key to be expired.

        Returns:
            tuple: A tuple containing a boolean value indicating the success of the operation, and an HTTP status code.
        &#34;&#34;&#34;

        Signing = self.get_model()

        signing_key = Signing.query.filter_by(signature=key).first()
        if not signing_key:
            return False

        # This will disable the key
        signing_key.active = False
        self.db.session.commit()
        return True

    def verify_signature(self, signature, scope):
        &#34;&#34;&#34;
        Verifies the validity of a given signing key against a specific scope.

        This function checks if the signing key exists, if it is active, if it has not expired,
        and if its scope matches the provided scope. If all these conditions are met, the function
        returns True, otherwise, it returns False.

        Args:
            signature (str): The signing key to be verified.
            scope (str): The scope against which the signing key will be validated.

        Returns:
            bool: True if the signing key is valid and False otherwise.
        &#34;&#34;&#34;

        Signing = self.get_model()


        signing_key = Signing.query.filter_by(signature=signature).first()

        # if the key doesn&#39;t exist
        if not signing_key:
            return False

        # if the signing key&#39;s expiration time has passed
        if signing_key.expiration &lt; datetime.datetime.utcnow():
            self.expire_key(signature)
            return False

        # if the signing key is set to inactive
        if not signing_key.active:
            return False

        # if the signing key&#39;s scope doesn&#39;t match the required scope
        if signing_key.scope != scope:
            return False

        return True

    def get_model(self):

        &#34;&#34;&#34;
        Generate an instance of the Signing class, which represents the Signing table in the database.

        Each instance of this class represents a row of data in the database table.

        Attributes:
            signature (str): The primary key of the Signing table. This field is unique for each entry.
            email (str): The email associated with a specific signing key.
            scope (str): The scope within which the key is valid.
            active (bool): The status of the signing key. If True, the key is active.
            timestamp (datetime): The date and time when the signing key was created.
            expiration (datetime): The date and time when the signing key is set to expire.
        &#34;&#34;&#34;

        if not hasattr(self, &#39;_model&#39;):
            class Signing(self.db.Model):
                __tablename__ = &#39;signing&#39;
                signature = self.db.Column(self.db.String(1000), primary_key=True) 
                email = self.db.Column(self.db.String(100))
                scope = self.db.Column(self.db.String(100))
                active = self.db.Column(self.db.Boolean)
                timestamp = self.db.Column(self.db.DateTime, nullable=False, default=datetime.datetime.utcnow)
                expiration = self.db.Column(self.db.DateTime, nullable=False, default=datetime.datetime.utcnow)

            self._model = Signing

        return self._model


    def query_keys(self, active:bool=None, scope:str=None, email:str=None) -&gt; Union[List[Dict[str, Any]], bool]:
        &#34;&#34;&#34;
        Query signing keys by active status, scope, and email.

        This function returns a list of signing keys that match the provided parameters.
        If no keys are found, it returns False.

        Args:
            active (bool, optional): The active status of the signing keys. Defaults to None.
            scope (str, optional): The scope of the signing keys. Defaults to None.
            email (str, optional): The email associated with the signing keys. Defaults to None.

        Returns:
            Union[List[Dict[str, Any]], bool]: A list of dictionaries where each dictionary contains the details of a signing key,
            or False if no keys are found.
        &#34;&#34;&#34;

        Signing = self.get_model()

        query = Signing.query

        if active is not None:
            query = query.filter(Signing.active == active)
        if scope:
            query = query.filter(Signing.scope == scope)
        if email:
            query = query.filter(Signing.email == email)

        result = query.all()

        if not result:
            return False

        return [{&#39;signature&#39;: key.signature, &#39;email&#39;: key.email, &#39;scope&#39;: key.scope, &#39;active&#39;: key.active, &#39;timestamp&#39;: key.timestamp, &#39;expiration&#39;: key.expiration} for key in result]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="flask_signing.Signatures"><code class="flex name class">
<span>class <span class="ident">Signatures</span></span>
<span>(</span><span>app, byte_len: int = 24)</span>
</code></dt>
<dd>
<div class="desc"><p>The Signatures class handles operations related to the creation, management, and validation
of signing keys in the database.</p>
<p>Initializes a new instance of the Signatures class.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>app</code></strong> :&ensp;<code>Flask</code></dt>
<dd>A flask object to contain the context for database interactions. </dd>
<dt><strong><code>byte_len</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The length of the generated signing keys. Defaults to 24.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Signatures:
    &#34;&#34;&#34;
    The Signatures class handles operations related to the creation, management, and validation 
    of signing keys in the database.
    &#34;&#34;&#34;
    
    def __init__(self, app, byte_len:int=24):
        &#34;&#34;&#34;
        Initializes a new instance of the Signatures class.

        Args:
            app (Flask): A flask object to contain the context for database interactions. 
            byte_len (int, optional): The length of the generated signing keys. Defaults to 24.
        &#34;&#34;&#34;

        self.db = SQLAlchemy(app)
        self.Signing = self.get_model()
        self.db.create_all()  # this will create all necessary tables

        # self.db = database
        self.byte_len = byte_len

    def generate_key(self, length:int=None) -&gt; str:
        &#34;&#34;&#34;
        Generates a signing key with the specified byte length. 
        Note: byte length generally translates to about 1.3 times as many chars,
        see https://docs.python.org/3/library/secrets.html.

        Args:
            length (int, optional): The length of the generated signing key. Defaults to None, in which case the byte_len is used.

        Returns:
            str: The generated signing key.
        &#34;&#34;&#34;

        if not length: 
            length = self.byte_len
        return secrets.token_urlsafe(length)

    def write_key_to_database(self, scope:str=None, expiration:int=1, active:bool=True, email:str=None) -&gt; str:
        &#34;&#34;&#34;
        Writes a newly generated signing key to the database.

        This function will continuously attempt to generate a key until a unique one is created. 

        Args:
            scope (str): The scope within which the signing key will be valid. Defaults to None.
            expiration (int, optional): The number of hours after which the signing key will expire. 
                If not provided or equals 0, the expiration will be set to zero. Defaults to 1.
            active (bool, optional): The status of the signing key. Defaults to True.
            email (str, optional): The email associated with the signing key. Defaults to None.

        Returns:
            str: The generated and written signing key.
        &#34;&#34;&#34;
        Signing = self.get_model()

        # loop until a unique key is generated
        while True:
            key = self.generate_key()
            if not Signing.query.filter_by(signature=key).first(): break

        new_key = Signing(
                        signature=key, 
                        scope=scope.lower() if scope else &#34;&#34;,
                        email=email.lower() if email else &#34;&#34;, 
                        active=active,
                        expiration=(datetime.datetime.utcnow() + datetime.timedelta(hours=expiration)) if expiration else 0,
                        timestamp=datetime.datetime.utcnow(),
        )

        self.db.session.add(new_key)
        self.db.session.commit()

        return key

    def expire_key(self, key):

        &#34;&#34;&#34;
        Expires a signing key in the database.

        This function finds the key in the database and disables it by setting its &#39;active&#39; status to False.
        If the key does not exist, the function returns False and an HTTP status code 500.

        Args:
            key (str): The signing key to be expired.

        Returns:
            tuple: A tuple containing a boolean value indicating the success of the operation, and an HTTP status code.
        &#34;&#34;&#34;

        Signing = self.get_model()

        signing_key = Signing.query.filter_by(signature=key).first()
        if not signing_key:
            return False

        # This will disable the key
        signing_key.active = False
        self.db.session.commit()
        return True

    def verify_signature(self, signature, scope):
        &#34;&#34;&#34;
        Verifies the validity of a given signing key against a specific scope.

        This function checks if the signing key exists, if it is active, if it has not expired,
        and if its scope matches the provided scope. If all these conditions are met, the function
        returns True, otherwise, it returns False.

        Args:
            signature (str): The signing key to be verified.
            scope (str): The scope against which the signing key will be validated.

        Returns:
            bool: True if the signing key is valid and False otherwise.
        &#34;&#34;&#34;

        Signing = self.get_model()


        signing_key = Signing.query.filter_by(signature=signature).first()

        # if the key doesn&#39;t exist
        if not signing_key:
            return False

        # if the signing key&#39;s expiration time has passed
        if signing_key.expiration &lt; datetime.datetime.utcnow():
            self.expire_key(signature)
            return False

        # if the signing key is set to inactive
        if not signing_key.active:
            return False

        # if the signing key&#39;s scope doesn&#39;t match the required scope
        if signing_key.scope != scope:
            return False

        return True

    def get_model(self):

        &#34;&#34;&#34;
        Generate an instance of the Signing class, which represents the Signing table in the database.

        Each instance of this class represents a row of data in the database table.

        Attributes:
            signature (str): The primary key of the Signing table. This field is unique for each entry.
            email (str): The email associated with a specific signing key.
            scope (str): The scope within which the key is valid.
            active (bool): The status of the signing key. If True, the key is active.
            timestamp (datetime): The date and time when the signing key was created.
            expiration (datetime): The date and time when the signing key is set to expire.
        &#34;&#34;&#34;

        if not hasattr(self, &#39;_model&#39;):
            class Signing(self.db.Model):
                __tablename__ = &#39;signing&#39;
                signature = self.db.Column(self.db.String(1000), primary_key=True) 
                email = self.db.Column(self.db.String(100))
                scope = self.db.Column(self.db.String(100))
                active = self.db.Column(self.db.Boolean)
                timestamp = self.db.Column(self.db.DateTime, nullable=False, default=datetime.datetime.utcnow)
                expiration = self.db.Column(self.db.DateTime, nullable=False, default=datetime.datetime.utcnow)

            self._model = Signing

        return self._model


    def query_keys(self, active:bool=None, scope:str=None, email:str=None) -&gt; Union[List[Dict[str, Any]], bool]:
        &#34;&#34;&#34;
        Query signing keys by active status, scope, and email.

        This function returns a list of signing keys that match the provided parameters.
        If no keys are found, it returns False.

        Args:
            active (bool, optional): The active status of the signing keys. Defaults to None.
            scope (str, optional): The scope of the signing keys. Defaults to None.
            email (str, optional): The email associated with the signing keys. Defaults to None.

        Returns:
            Union[List[Dict[str, Any]], bool]: A list of dictionaries where each dictionary contains the details of a signing key,
            or False if no keys are found.
        &#34;&#34;&#34;

        Signing = self.get_model()

        query = Signing.query

        if active is not None:
            query = query.filter(Signing.active == active)
        if scope:
            query = query.filter(Signing.scope == scope)
        if email:
            query = query.filter(Signing.email == email)

        result = query.all()

        if not result:
            return False

        return [{&#39;signature&#39;: key.signature, &#39;email&#39;: key.email, &#39;scope&#39;: key.scope, &#39;active&#39;: key.active, &#39;timestamp&#39;: key.timestamp, &#39;expiration&#39;: key.expiration} for key in result]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="flask_signing.Signatures.expire_key"><code class="name flex">
<span>def <span class="ident">expire_key</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Expires a signing key in the database.</p>
<p>This function finds the key in the database and disables it by setting its 'active' status to False.
If the key does not exist, the function returns False and an HTTP status code 500.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The signing key to be expired.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>A tuple containing a boolean value indicating the success of the operation, and an HTTP status code.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expire_key(self, key):

    &#34;&#34;&#34;
    Expires a signing key in the database.

    This function finds the key in the database and disables it by setting its &#39;active&#39; status to False.
    If the key does not exist, the function returns False and an HTTP status code 500.

    Args:
        key (str): The signing key to be expired.

    Returns:
        tuple: A tuple containing a boolean value indicating the success of the operation, and an HTTP status code.
    &#34;&#34;&#34;

    Signing = self.get_model()

    signing_key = Signing.query.filter_by(signature=key).first()
    if not signing_key:
        return False

    # This will disable the key
    signing_key.active = False
    self.db.session.commit()
    return True</code></pre>
</details>
</dd>
<dt id="flask_signing.Signatures.generate_key"><code class="name flex">
<span>def <span class="ident">generate_key</span></span>(<span>self, length: int = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generates a signing key with the specified byte length.
Note: byte length generally translates to about 1.3 times as many chars,
see <a href="https://docs.python.org/3/library/secrets.html.">https://docs.python.org/3/library/secrets.html.</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The length of the generated signing key. Defaults to None, in which case the byte_len is used.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated signing key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_key(self, length:int=None) -&gt; str:
    &#34;&#34;&#34;
    Generates a signing key with the specified byte length. 
    Note: byte length generally translates to about 1.3 times as many chars,
    see https://docs.python.org/3/library/secrets.html.

    Args:
        length (int, optional): The length of the generated signing key. Defaults to None, in which case the byte_len is used.

    Returns:
        str: The generated signing key.
    &#34;&#34;&#34;

    if not length: 
        length = self.byte_len
    return secrets.token_urlsafe(length)</code></pre>
</details>
</dd>
<dt id="flask_signing.Signatures.get_model"><code class="name flex">
<span>def <span class="ident">get_model</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate an instance of the Signing class, which represents the Signing table in the database.</p>
<p>Each instance of this class represents a row of data in the database table.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>signature</code></strong> :&ensp;<code>str</code></dt>
<dd>The primary key of the Signing table. This field is unique for each entry.</dd>
<dt><strong><code>email</code></strong> :&ensp;<code>str</code></dt>
<dd>The email associated with a specific signing key.</dd>
<dt><strong><code>scope</code></strong> :&ensp;<code>str</code></dt>
<dd>The scope within which the key is valid.</dd>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code></dt>
<dd>The status of the signing key. If True, the key is active.</dd>
<dt><strong><code>timestamp</code></strong> :&ensp;<code>datetime</code></dt>
<dd>The date and time when the signing key was created.</dd>
<dt><strong><code>expiration</code></strong> :&ensp;<code>datetime</code></dt>
<dd>The date and time when the signing key is set to expire.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_model(self):

    &#34;&#34;&#34;
    Generate an instance of the Signing class, which represents the Signing table in the database.

    Each instance of this class represents a row of data in the database table.

    Attributes:
        signature (str): The primary key of the Signing table. This field is unique for each entry.
        email (str): The email associated with a specific signing key.
        scope (str): The scope within which the key is valid.
        active (bool): The status of the signing key. If True, the key is active.
        timestamp (datetime): The date and time when the signing key was created.
        expiration (datetime): The date and time when the signing key is set to expire.
    &#34;&#34;&#34;

    if not hasattr(self, &#39;_model&#39;):
        class Signing(self.db.Model):
            __tablename__ = &#39;signing&#39;
            signature = self.db.Column(self.db.String(1000), primary_key=True) 
            email = self.db.Column(self.db.String(100))
            scope = self.db.Column(self.db.String(100))
            active = self.db.Column(self.db.Boolean)
            timestamp = self.db.Column(self.db.DateTime, nullable=False, default=datetime.datetime.utcnow)
            expiration = self.db.Column(self.db.DateTime, nullable=False, default=datetime.datetime.utcnow)

        self._model = Signing

    return self._model</code></pre>
</details>
</dd>
<dt id="flask_signing.Signatures.query_keys"><code class="name flex">
<span>def <span class="ident">query_keys</span></span>(<span>self, active: bool = None, scope: str = None, email: str = None) ‑> Union[List[Dict[str, Any]], bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Query signing keys by active status, scope, and email.</p>
<p>This function returns a list of signing keys that match the provided parameters.
If no keys are found, it returns False.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>The active status of the signing keys. Defaults to None.</dd>
<dt><strong><code>scope</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The scope of the signing keys. Defaults to None.</dd>
<dt><strong><code>email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email associated with the signing keys. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[List[Dict[str, Any]], bool]</code></dt>
<dd>A list of dictionaries where each dictionary contains the details of a signing key,</dd>
</dl>
<p>or False if no keys are found.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query_keys(self, active:bool=None, scope:str=None, email:str=None) -&gt; Union[List[Dict[str, Any]], bool]:
    &#34;&#34;&#34;
    Query signing keys by active status, scope, and email.

    This function returns a list of signing keys that match the provided parameters.
    If no keys are found, it returns False.

    Args:
        active (bool, optional): The active status of the signing keys. Defaults to None.
        scope (str, optional): The scope of the signing keys. Defaults to None.
        email (str, optional): The email associated with the signing keys. Defaults to None.

    Returns:
        Union[List[Dict[str, Any]], bool]: A list of dictionaries where each dictionary contains the details of a signing key,
        or False if no keys are found.
    &#34;&#34;&#34;

    Signing = self.get_model()

    query = Signing.query

    if active is not None:
        query = query.filter(Signing.active == active)
    if scope:
        query = query.filter(Signing.scope == scope)
    if email:
        query = query.filter(Signing.email == email)

    result = query.all()

    if not result:
        return False

    return [{&#39;signature&#39;: key.signature, &#39;email&#39;: key.email, &#39;scope&#39;: key.scope, &#39;active&#39;: key.active, &#39;timestamp&#39;: key.timestamp, &#39;expiration&#39;: key.expiration} for key in result]</code></pre>
</details>
</dd>
<dt id="flask_signing.Signatures.verify_signature"><code class="name flex">
<span>def <span class="ident">verify_signature</span></span>(<span>self, signature, scope)</span>
</code></dt>
<dd>
<div class="desc"><p>Verifies the validity of a given signing key against a specific scope.</p>
<p>This function checks if the signing key exists, if it is active, if it has not expired,
and if its scope matches the provided scope. If all these conditions are met, the function
returns True, otherwise, it returns False.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>signature</code></strong> :&ensp;<code>str</code></dt>
<dd>The signing key to be verified.</dd>
<dt><strong><code>scope</code></strong> :&ensp;<code>str</code></dt>
<dd>The scope against which the signing key will be validated.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the signing key is valid and False otherwise.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_signature(self, signature, scope):
    &#34;&#34;&#34;
    Verifies the validity of a given signing key against a specific scope.

    This function checks if the signing key exists, if it is active, if it has not expired,
    and if its scope matches the provided scope. If all these conditions are met, the function
    returns True, otherwise, it returns False.

    Args:
        signature (str): The signing key to be verified.
        scope (str): The scope against which the signing key will be validated.

    Returns:
        bool: True if the signing key is valid and False otherwise.
    &#34;&#34;&#34;

    Signing = self.get_model()


    signing_key = Signing.query.filter_by(signature=signature).first()

    # if the key doesn&#39;t exist
    if not signing_key:
        return False

    # if the signing key&#39;s expiration time has passed
    if signing_key.expiration &lt; datetime.datetime.utcnow():
        self.expire_key(signature)
        return False

    # if the signing key is set to inactive
    if not signing_key.active:
        return False

    # if the signing key&#39;s scope doesn&#39;t match the required scope
    if signing_key.scope != scope:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="flask_signing.Signatures.write_key_to_database"><code class="name flex">
<span>def <span class="ident">write_key_to_database</span></span>(<span>self, scope: str = None, expiration: int = 1, active: bool = True, email: str = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Writes a newly generated signing key to the database.</p>
<p>This function will continuously attempt to generate a key until a unique one is created. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>scope</code></strong> :&ensp;<code>str</code></dt>
<dd>The scope within which the signing key will be valid. Defaults to None.</dd>
<dt><strong><code>expiration</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of hours after which the signing key will expire.
If not provided or equals 0, the expiration will be set to zero. Defaults to 1.</dd>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>The status of the signing key. Defaults to True.</dd>
<dt><strong><code>email</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The email associated with the signing key. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The generated and written signing key.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_key_to_database(self, scope:str=None, expiration:int=1, active:bool=True, email:str=None) -&gt; str:
    &#34;&#34;&#34;
    Writes a newly generated signing key to the database.

    This function will continuously attempt to generate a key until a unique one is created. 

    Args:
        scope (str): The scope within which the signing key will be valid. Defaults to None.
        expiration (int, optional): The number of hours after which the signing key will expire. 
            If not provided or equals 0, the expiration will be set to zero. Defaults to 1.
        active (bool, optional): The status of the signing key. Defaults to True.
        email (str, optional): The email associated with the signing key. Defaults to None.

    Returns:
        str: The generated and written signing key.
    &#34;&#34;&#34;
    Signing = self.get_model()

    # loop until a unique key is generated
    while True:
        key = self.generate_key()
        if not Signing.query.filter_by(signature=key).first(): break

    new_key = Signing(
                    signature=key, 
                    scope=scope.lower() if scope else &#34;&#34;,
                    email=email.lower() if email else &#34;&#34;, 
                    active=active,
                    expiration=(datetime.datetime.utcnow() + datetime.timedelta(hours=expiration)) if expiration else 0,
                    timestamp=datetime.datetime.utcnow(),
    )

    self.db.session.add(new_key)
    self.db.session.commit()

    return key</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="flask_signing.Signatures" href="#flask_signing.Signatures">Signatures</a></code></h4>
<ul class="">
<li><code><a title="flask_signing.Signatures.expire_key" href="#flask_signing.Signatures.expire_key">expire_key</a></code></li>
<li><code><a title="flask_signing.Signatures.generate_key" href="#flask_signing.Signatures.generate_key">generate_key</a></code></li>
<li><code><a title="flask_signing.Signatures.get_model" href="#flask_signing.Signatures.get_model">get_model</a></code></li>
<li><code><a title="flask_signing.Signatures.query_keys" href="#flask_signing.Signatures.query_keys">query_keys</a></code></li>
<li><code><a title="flask_signing.Signatures.verify_signature" href="#flask_signing.Signatures.verify_signature">verify_signature</a></code></li>
<li><code><a title="flask_signing.Signatures.write_key_to_database" href="#flask_signing.Signatures.write_key_to_database">write_key_to_database</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>